/*
 * generated by Xtext 2.27.0
 */
package fr.centralesupelec.infonum.sl.miniarm.serializer;

import com.google.inject.Inject;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.ADD;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.BEQ;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.BLINK;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.BLT;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.BRANCH;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.CMP;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.Const;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.Direct;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.DirectReg;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.HexConst;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.Immediate;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.Include;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.LOAD;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.Label;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.LabelDef;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.Line;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.MOVE;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.MiniARMPackage;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.POP;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.PUSH;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.Program;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.RMW;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.Register;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.SMS;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.SMW;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.STORE;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.SUB;
import fr.centralesupelec.infonum.sl.miniarm.miniARM.Value;
import fr.centralesupelec.infonum.sl.miniarm.services.MiniARMGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MiniARMSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MiniARMGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MiniARMPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MiniARMPackage.ADD:
				sequence_ADD(context, (ADD) semanticObject); 
				return; 
			case MiniARMPackage.BEQ:
				sequence_BEQ(context, (BEQ) semanticObject); 
				return; 
			case MiniARMPackage.BLINK:
				sequence_BLINK(context, (BLINK) semanticObject); 
				return; 
			case MiniARMPackage.BLT:
				sequence_BLT(context, (BLT) semanticObject); 
				return; 
			case MiniARMPackage.BRANCH:
				sequence_BRANCH(context, (BRANCH) semanticObject); 
				return; 
			case MiniARMPackage.CMP:
				sequence_CMP(context, (CMP) semanticObject); 
				return; 
			case MiniARMPackage.CONST:
				sequence_Const(context, (Const) semanticObject); 
				return; 
			case MiniARMPackage.DIRECT:
				sequence_Direct(context, (Direct) semanticObject); 
				return; 
			case MiniARMPackage.DIRECT_REG:
				sequence_DirectReg(context, (DirectReg) semanticObject); 
				return; 
			case MiniARMPackage.HEX_CONST:
				sequence_HexConst(context, (HexConst) semanticObject); 
				return; 
			case MiniARMPackage.IMMEDIATE:
				sequence_Immediate(context, (Immediate) semanticObject); 
				return; 
			case MiniARMPackage.INCLUDE:
				sequence_Include(context, (Include) semanticObject); 
				return; 
			case MiniARMPackage.LOAD:
				sequence_LOAD(context, (LOAD) semanticObject); 
				return; 
			case MiniARMPackage.LABEL:
				sequence_Label(context, (Label) semanticObject); 
				return; 
			case MiniARMPackage.LABEL_DEF:
				sequence_LabelDef(context, (LabelDef) semanticObject); 
				return; 
			case MiniARMPackage.LINE:
				sequence_Line(context, (Line) semanticObject); 
				return; 
			case MiniARMPackage.MOVE:
				sequence_MOVE(context, (MOVE) semanticObject); 
				return; 
			case MiniARMPackage.POP:
				sequence_POP(context, (POP) semanticObject); 
				return; 
			case MiniARMPackage.PUSH:
				sequence_PUSH(context, (PUSH) semanticObject); 
				return; 
			case MiniARMPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case MiniARMPackage.RMW:
				sequence_RMW(context, (RMW) semanticObject); 
				return; 
			case MiniARMPackage.REGISTER:
				sequence_Register(context, (Register) semanticObject); 
				return; 
			case MiniARMPackage.SMS:
				sequence_SMS(context, (SMS) semanticObject); 
				return; 
			case MiniARMPackage.SMW:
				sequence_SMW(context, (SMW) semanticObject); 
				return; 
			case MiniARMPackage.STORE:
				sequence_STORE(context, (STORE) semanticObject); 
				return; 
			case MiniARMPackage.SUB:
				sequence_SUB(context, (SUB) semanticObject); 
				return; 
			case MiniARMPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns ADD
	 *     RealInst returns ADD
	 *     ADD returns ADD
	 *
	 * Constraint:
	 *     (dst=Register src1=Register src2=MoveValue)
	 * </pre>
	 */
	protected void sequence_ADD(ISerializationContext context, ADD semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.ADD__DST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.ADD__DST));
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.ADD__SRC1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.ADD__SRC1));
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.ADD__SRC2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.ADD__SRC2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getADDAccess().getDstRegisterParserRuleCall_1_0(), semanticObject.getDst());
		feeder.accept(grammarAccess.getADDAccess().getSrc1RegisterParserRuleCall_3_0(), semanticObject.getSrc1());
		feeder.accept(grammarAccess.getADDAccess().getSrc2MoveValueParserRuleCall_5_0(), semanticObject.getSrc2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns BEQ
	 *     RealInst returns BEQ
	 *     BEQ returns BEQ
	 *
	 * Constraint:
	 *     dest=BranchAddress
	 * </pre>
	 */
	protected void sequence_BEQ(ISerializationContext context, BEQ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.BEQ__DEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.BEQ__DEST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBEQAccess().getDestBranchAddressParserRuleCall_1_0(), semanticObject.getDest());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns BLINK
	 *     RealInst returns BLINK
	 *     BLINK returns BLINK
	 *
	 * Constraint:
	 *     (reg=Register dest=BranchAddress)
	 * </pre>
	 */
	protected void sequence_BLINK(ISerializationContext context, BLINK semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.BLINK__REG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.BLINK__REG));
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.BLINK__DEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.BLINK__DEST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBLINKAccess().getRegRegisterParserRuleCall_1_0(), semanticObject.getReg());
		feeder.accept(grammarAccess.getBLINKAccess().getDestBranchAddressParserRuleCall_3_0(), semanticObject.getDest());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns BLT
	 *     RealInst returns BLT
	 *     BLT returns BLT
	 *
	 * Constraint:
	 *     dest=BranchAddress
	 * </pre>
	 */
	protected void sequence_BLT(ISerializationContext context, BLT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.BLT__DEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.BLT__DEST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBLTAccess().getDestBranchAddressParserRuleCall_1_0(), semanticObject.getDest());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns BRANCH
	 *     RealInst returns BRANCH
	 *     BRANCH returns BRANCH
	 *
	 * Constraint:
	 *     dest=BranchAddress
	 * </pre>
	 */
	protected void sequence_BRANCH(ISerializationContext context, BRANCH semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.BRANCH__DEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.BRANCH__DEST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBRANCHAccess().getDestBranchAddressParserRuleCall_1_0(), semanticObject.getDest());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns CMP
	 *     RealInst returns CMP
	 *     CMP returns CMP
	 *
	 * Constraint:
	 *     (src1=Register src2=MoveValue)
	 * </pre>
	 */
	protected void sequence_CMP(ISerializationContext context, CMP semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.CMP__SRC1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.CMP__SRC1));
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.CMP__SRC2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.CMP__SRC2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCMPAccess().getSrc1RegisterParserRuleCall_1_0(), semanticObject.getSrc1());
		feeder.accept(grammarAccess.getCMPAccess().getSrc2MoveValueParserRuleCall_3_0(), semanticObject.getSrc2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns Const
	 *     Const returns Const
	 *     BranchAddress returns Const
	 *
	 * Constraint:
	 *     num=INT
	 * </pre>
	 */
	protected void sequence_Const(ISerializationContext context, Const semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.VALUE__NUM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.VALUE__NUM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstAccess().getNumINTTerminalRuleCall_0(), semanticObject.getNum());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DirectReg returns DirectReg
	 *     Address returns DirectReg
	 *
	 * Constraint:
	 *     reg=Register
	 * </pre>
	 */
	protected void sequence_DirectReg(ISerializationContext context, DirectReg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.DIRECT_REG__REG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.DIRECT_REG__REG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDirectRegAccess().getRegRegisterParserRuleCall_1_0(), semanticObject.getReg());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Direct returns Direct
	 *     Address returns Direct
	 *
	 * Constraint:
	 *     address=Value
	 * </pre>
	 */
	protected void sequence_Direct(ISerializationContext context, Direct semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.DIRECT__ADDRESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.DIRECT__ADDRESS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDirectAccess().getAddressValueParserRuleCall_0(), semanticObject.getAddress());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns HexConst
	 *     HexConst returns HexConst
	 *     BranchAddress returns HexConst
	 *
	 * Constraint:
	 *     num=HEXINT
	 * </pre>
	 */
	protected void sequence_HexConst(ISerializationContext context, HexConst semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.VALUE__NUM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.VALUE__NUM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHexConstAccess().getNumHEXINTTerminalRuleCall_0(), semanticObject.getNum());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Immediate returns Immediate
	 *     MoveValue returns Immediate
	 *
	 * Constraint:
	 *     value=Value
	 * </pre>
	 */
	protected void sequence_Immediate(ISerializationContext context, Immediate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.IMMEDIATE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.IMMEDIATE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImmediateAccess().getValueValueParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Line returns Include
	 *     Include returns Include
	 *
	 * Constraint:
	 *     fileName=STRING
	 * </pre>
	 */
	protected void sequence_Include(ISerializationContext context, Include semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.INCLUDE__FILE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.INCLUDE__FILE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIncludeAccess().getFileNameSTRINGTerminalRuleCall_1_0(), semanticObject.getFileName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns LOAD
	 *     RealInst returns LOAD
	 *     LOAD returns LOAD
	 *
	 * Constraint:
	 *     (reg=Register address=Address)
	 * </pre>
	 */
	protected void sequence_LOAD(ISerializationContext context, LOAD semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.LOAD__REG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.LOAD__REG));
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.LOAD__ADDRESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.LOAD__ADDRESS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLOADAccess().getRegRegisterParserRuleCall_1_0(), semanticObject.getReg());
		feeder.accept(grammarAccess.getLOADAccess().getAddressAddressParserRuleCall_3_0(), semanticObject.getAddress());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LabelDef returns LabelDef
	 *
	 * Constraint:
	 *     label=Label
	 * </pre>
	 */
	protected void sequence_LabelDef(ISerializationContext context, LabelDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.LABEL_DEF__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.LABEL_DEF__LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelDefAccess().getLabelLabelParserRuleCall_1_0(), semanticObject.getLabel());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Label returns Label
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Label(ISerializationContext context, Label semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.LABEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.LABEL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Line returns Line
	 *
	 * Constraint:
	 *     (labelDef=LabelDef? inst=Instruction? comment=SL_COMMENT?)
	 * </pre>
	 */
	protected void sequence_Line(ISerializationContext context, Line semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns MOVE
	 *     RealInst returns MOVE
	 *     MOVE returns MOVE
	 *
	 * Constraint:
	 *     (dst=Register src=MoveValue)
	 * </pre>
	 */
	protected void sequence_MOVE(ISerializationContext context, MOVE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.MOVE__DST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.MOVE__DST));
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.MOVE__SRC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.MOVE__SRC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMOVEAccess().getDstRegisterParserRuleCall_1_0(), semanticObject.getDst());
		feeder.accept(grammarAccess.getMOVEAccess().getSrcMoveValueParserRuleCall_3_0(), semanticObject.getSrc());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns POP
	 *     PseudoInst returns POP
	 *     POP returns POP
	 *
	 * Constraint:
	 *     reg=Register
	 * </pre>
	 */
	protected void sequence_POP(ISerializationContext context, POP semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.PSEUDO_INST__REG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.PSEUDO_INST__REG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPOPAccess().getRegRegisterParserRuleCall_1_0(), semanticObject.getReg());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns PUSH
	 *     PseudoInst returns PUSH
	 *     PUSH returns PUSH
	 *
	 * Constraint:
	 *     reg=Register
	 * </pre>
	 */
	protected void sequence_PUSH(ISerializationContext context, PUSH semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.PSEUDO_INST__REG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.PSEUDO_INST__REG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPUSHAccess().getRegRegisterParserRuleCall_1_0(), semanticObject.getReg());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     lines+=Line+
	 * </pre>
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns RMW
	 *     AssemblyInst returns RMW
	 *     RMW returns RMW
	 *
	 * Constraint:
	 *     size=Const
	 * </pre>
	 */
	protected void sequence_RMW(ISerializationContext context, RMW semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.RMW__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.RMW__SIZE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRMWAccess().getSizeConstParserRuleCall_1_0(), semanticObject.getSize());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Register returns Register
	 *     MoveValue returns Register
	 *     BranchAddress returns Register
	 *
	 * Constraint:
	 *     (
	 *         name='r0' | 
	 *         name='r1' | 
	 *         name='r2' | 
	 *         name='r3' | 
	 *         name='r4' | 
	 *         name='r5' | 
	 *         name='r6' | 
	 *         name='sp' | 
	 *         name='r7' | 
	 *         name='lr'
	 *     )
	 * </pre>
	 */
	protected void sequence_Register(ISerializationContext context, Register semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns SMS
	 *     AssemblyInst returns SMS
	 *     SMS returns SMS
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_SMS(ISerializationContext context, SMS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.SMS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.SMS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSMSAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns SMW
	 *     AssemblyInst returns SMW
	 *     SMW returns SMW
	 *
	 * Constraint:
	 *     value=Const
	 * </pre>
	 */
	protected void sequence_SMW(ISerializationContext context, SMW semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.SMW__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.SMW__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSMWAccess().getValueConstParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns STORE
	 *     RealInst returns STORE
	 *     STORE returns STORE
	 *
	 * Constraint:
	 *     (reg=Register address=Address)
	 * </pre>
	 */
	protected void sequence_STORE(ISerializationContext context, STORE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.STORE__REG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.STORE__REG));
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.STORE__ADDRESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.STORE__ADDRESS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSTOREAccess().getRegRegisterParserRuleCall_1_0(), semanticObject.getReg());
		feeder.accept(grammarAccess.getSTOREAccess().getAddressAddressParserRuleCall_3_0(), semanticObject.getAddress());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns SUB
	 *     RealInst returns SUB
	 *     SUB returns SUB
	 *
	 * Constraint:
	 *     (dst=Register src1=Register src2=MoveValue)
	 * </pre>
	 */
	protected void sequence_SUB(ISerializationContext context, SUB semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.SUB__DST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.SUB__DST));
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.SUB__SRC1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.SUB__SRC1));
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.SUB__SRC2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.SUB__SRC2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSUBAccess().getDstRegisterParserRuleCall_1_0(), semanticObject.getDst());
		feeder.accept(grammarAccess.getSUBAccess().getSrc1RegisterParserRuleCall_3_0(), semanticObject.getSrc1());
		feeder.accept(grammarAccess.getSUBAccess().getSrc2MoveValueParserRuleCall_5_0(), semanticObject.getSrc2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns Value
	 *     BranchAddress returns Value
	 *
	 * Constraint:
	 *     label=[Label|ID]
	 * </pre>
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniARMPackage.Literals.VALUE__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniARMPackage.Literals.VALUE__LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueAccess().getLabelLabelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MiniARMPackage.Literals.VALUE__LABEL, false));
		feeder.finish();
	}
	
	
}
